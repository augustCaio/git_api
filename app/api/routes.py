"""
Endpoints da API para dados do GitHub
"""

from typing import List, Optional
from datetime import datetime
from fastapi import APIRouter, HTTPException, Query, Depends
from app.services.github_client import GitHubClient
from app.models.github_models import (
    GitHubUser,
    GitHubRepository,
    GitHubLanguage,
    GitHubEvent,
    GitHubCommit,
    GitHubIssue,
    GitHubPullRequest,
)
from app.config import settings

router = APIRouter(prefix="/api/v1", tags=["GitHub Data"])


async def get_github_client() -> GitHubClient:
    """Dependency para obter o cliente do GitHub"""
    return GitHubClient()


@router.get("/users/{username}", response_model=GitHubUser, summary="Obter dados de usu√°rio", tags=["Usu√°rios"])
async def get_user(
    username: str,
    client: GitHubClient = Depends(get_github_client)
) -> GitHubUser:
    """
    ## üë§ Dados do Usu√°rio
    
    Obt√©m informa√ß√µes completas de um usu√°rio do GitHub.
    
    ### üìä Dados Retornados
    
    - **Informa√ß√µes b√°sicas**: ID, login, nome, email, bio
    - **Localiza√ß√£o**: Pa√≠s, cidade, empresa
    - **Estat√≠sticas**: Reposit√≥rios p√∫blicos, seguidores, seguindo
    - **Links**: Avatar, blog, site pessoal
    - **Status**: Tipo de conta, admin, verificado
    
    ### üîÑ Uso
    
    ```bash
    curl https://git-api-i3y5.onrender.com/api/v1/users/octocat
    ```
    
    ### üìù Exemplo de Resposta
    
    ```json
    {
      "id": 583231,
      "login": "octocat",
      "name": "The Octocat",
      "email": null,
      "avatar_url": "https://avatars.githubusercontent.com/u/583231?v=4",
      "bio": "GitHub mascot",
      "location": "San Francisco",
      "company": "@github",
      "public_repos": 10,
      "followers": 100,
      "following": 50
    }
    ```
    
    ### ‚ö†Ô∏è Limita√ß√µes
    
    - Rate limit da API do GitHub: 60 requisi√ß√µes/hora (sem token)
    - Dados em cache por 5 minutos para melhor performance
    
    Args:
        username (str): Nome do usu√°rio no GitHub

    Returns:
        GitHubUser: Dados completos do usu√°rio
    """
    try:
        return await client.get_user(username)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Usu√°rio {username} n√£o encontrado: {str(e)}")


@router.get("/users/{username}/repositories", response_model=List[GitHubRepository], summary="Obter todos os reposit√≥rios do usu√°rio", tags=["Usu√°rios"])
async def get_user_repositories(
    username: str,
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubRepository]:
    """
    ## üìö Todos os Reposit√≥rios do Usu√°rio
    
    Obt√©m **todos os reposit√≥rios** de um usu√°rio do GitHub, incluindo:
    
    - ‚úÖ **Reposit√≥rios p√∫blicos** (vis√≠veis para todos)
    - ‚úÖ **Reposit√≥rios privados** (se voc√™ tiver acesso)
    - ‚úÖ **Reposit√≥rios forkados** (criados a partir de outros)
    - ‚úÖ **Reposit√≥rios originais** (criados pelo usu√°rio)
    
    ### üìä Dados Retornados
    
    Para cada reposit√≥rio:
    - **Informa√ß√µes b√°sicas**: Nome, descri√ß√£o, linguagem principal
    - **Estat√≠sticas**: Stars, forks, issues, watchers
    - **Configura√ß√µes**: Privado/p√∫blico, fork, arquivado
    - **Metadados**: Data de cria√ß√£o, √∫ltima atualiza√ß√£o, tamanho
    - **Links**: URL do reposit√≥rio, homepage, documenta√ß√£o
    
    ### üîÑ Uso
    
    ```bash
    # Todos os reposit√≥rios (primeira p√°gina)
    curl https://git-api-i3y5.onrender.com/api/v1/users/augustcaio/repositories
    
    # Com pagina√ß√£o
    curl https://git-api-i3y5.onrender.com/api/v1/users/augustcaio/repositories?page=1&per_page=50
    
    # M√°ximo de reposit√≥rios por p√°gina
    curl https://git-api-i3y5.onrender.com/api/v1/users/augustcaio/repositories?per_page=100
    ```
    
    ### üìù Exemplo de Resposta
    
    ```json
    [
      {
        "id": 1031918183,
        "name": "portfolio-2025",
        "full_name": "augustcaio/portfolio-2025",
        "description": "Meu portf√≥lio pessoal 2025",
        "private": false,
        "fork": false,
        "language": "TypeScript",
        "size": 1024,
        "stargazers_count": 5,
        "watchers_count": 5,
        "forks_count": 2,
        "open_issues_count": 1,
        "default_branch": "main",
        "created_at": "2025-01-15T10:30:00Z",
        "updated_at": "2025-07-29T16:00:00Z"
      },
      {
        "id": 1028484319,
        "name": "git_api",
        "full_name": "augustcaio/git_api",
        "description": "API para dados do GitHub",
        "private": false,
        "fork": false,
        "language": "Python",
        "size": 2048,
        "stargazers_count": 10,
        "watchers_count": 10,
        "forks_count": 3,
        "open_issues_count": 0,
        "default_branch": "main",
        "created_at": "2025-01-10T14:20:00Z",
        "updated_at": "2025-07-29T15:30:00Z"
      }
    ]
    ```
    
    ### ‚öôÔ∏è Par√¢metros
    
    - **username** (obrigat√≥rio): Nome do usu√°rio no GitHub
    - **page** (opcional): N√∫mero da p√°gina (padr√£o: 1)
    - **per_page** (opcional): Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
    
    ### ‚ö†Ô∏è Limita√ß√µes
    
    - **Rate limit**: 60 requisi√ß√µes/hora (sem token) / 5000 requisi√ß√µes/hora (com token)
    - **Cache**: Dados em cache por 10 minutos para melhor performance
    - **Reposit√≥rios privados**: S√≥ aparecem se voc√™ tiver acesso (com token)
    - **Ordena√ß√£o**: Reposit√≥rios ordenados por data de atualiza√ß√£o (mais recentes primeiro)
    
    ### üîó Endpoints Relacionados
    
    - `GET /users/{username}` - Dados do usu√°rio
    - `GET /users/{username}/languages` - Linguagens mais usadas
    - `GET /users/{username}/stats` - Estat√≠sticas completas
    - `GET /repos/{owner}/{repo}` - Dados de um reposit√≥rio espec√≠fico
    
    Args:
        username (str): Nome do usu√°rio no GitHub
        page (int): N√∫mero da p√°gina (padr√£o: 1)
        per_page (int): Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        List[GitHubRepository]: Lista completa de reposit√≥rios do usu√°rio
    """
    try:
        return await client.get_user_repositories(username, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar reposit√≥rios: {str(e)}")


@router.get("/users/{username}/repositories/summary", summary="Resumo de todos os reposit√≥rios do usu√°rio", tags=["Usu√°rios"])
async def get_user_repositories_summary(
    username: str,
    client: GitHubClient = Depends(get_github_client)
) -> dict:
    """
    ## üìä Resumo Completo dos Reposit√≥rios
    
    Obt√©m um **resumo estat√≠stico** de todos os reposit√≥rios de um usu√°rio, incluindo:
    
    - üìà **Estat√≠sticas gerais**: Total de reposit√≥rios, stars, forks
    - üó£Ô∏è **Linguagens mais usadas**: Ranking das linguagens de programa√ß√£o
    - üìÖ **Atividade recente**: Reposit√≥rios mais atualizados
    - ‚≠ê **Reposit√≥rios populares**: Com mais stars e forks
    - üîí **Visibilidade**: Distribui√ß√£o entre p√∫blicos e privados
    
    ### üìä Dados Retornados
    
    ```json
    {
      "username": "augustcaio",
      "summary": {
        "total_repositories": 5,
        "public_repositories": 4,
        "private_repositories": 1,
        "total_stars": 25,
        "total_forks": 8,
        "total_watchers": 30,
        "total_size": 10240
      },
      "languages": {
        "Python": {"count": 2, "percentage": 40.0},
        "TypeScript": {"count": 1, "percentage": 20.0},
        "JavaScript": {"count": 1, "percentage": 20.0}
      },
      "top_repositories": [
        {
          "name": "git_api",
          "stars": 10,
          "forks": 3,
          "language": "Python"
        }
      ],
      "recent_activity": [
        {
          "name": "portfolio-2025",
          "updated_at": "2025-07-29T16:00:00Z",
          "language": "TypeScript"
        }
      ]
    }
    ```
    
    ### üîÑ Uso
    
    ```bash
    curl https://git-api-i3y5.onrender.com/api/v1/users/augustcaio/repositories/summary
    ```
    
    ### ‚ö†Ô∏è Limita√ß√µes
    
    - **Rate limit**: 60 requisi√ß√µes/hora (sem token) / 5000 requisi√ß√µes/hora (com token)
    - **Cache**: Dados em cache por 15 minutos para melhor performance
    - **Reposit√≥rios privados**: S√≥ aparecem se voc√™ tiver acesso (com token)
    
    Args:
        username (str): Nome do usu√°rio no GitHub
        
    Returns:
        dict: Resumo estat√≠stico completo dos reposit√≥rios
    """
    try:
        # Obt√©m todos os reposit√≥rios (m√°ximo 100 por p√°gina)
        all_repos = await client.get_user_repositories(username, page=1, per_page=100)
        
        if not all_repos:
            return {
                "username": username,
                "summary": {
                    "total_repositories": 0,
                    "public_repositories": 0,
                    "private_repositories": 0,
                    "total_stars": 0,
                    "total_forks": 0,
                    "total_watchers": 0,
                    "total_size": 0
                },
                "languages": {},
                "top_repositories": [],
                "recent_activity": []
            }
        
        # Calcula estat√≠sticas
        total_repos = len(all_repos)
        public_repos = len([r for r in all_repos if not r.private])
        private_repos = len([r for r in all_repos if r.private])
        total_stars = sum(r.stargazers_count for r in all_repos)
        total_forks = sum(r.forks_count for r in all_repos)
        total_watchers = sum(r.watchers_count for r in all_repos)
        total_size = sum(r.size for r in all_repos)
        
        # An√°lise de linguagens
        languages = {}
        for repo in all_repos:
            if repo.language:
                if repo.language not in languages:
                    languages[repo.language] = {"count": 0, "percentage": 0}
                languages[repo.language]["count"] += 1
        
        # Calcula porcentagens
        for lang in languages:
            languages[lang]["percentage"] = (languages[lang]["count"] / total_repos) * 100
        
        # Top reposit√≥rios (por stars)
        top_repos = sorted(all_repos, key=lambda x: x.stargazers_count, reverse=True)[:5]
        top_repos_data = [
            {
                "name": repo.name,
                "full_name": repo.full_name,
                "stars": repo.stargazers_count,
                "forks": repo.forks_count,
                "language": repo.language,
                "description": repo.description
            }
            for repo in top_repos
        ]
        
        # Atividade recente
        recent_repos = sorted(all_repos, key=lambda x: x.updated_at or datetime.min, reverse=True)[:5]
        recent_activity = [
            {
                "name": repo.name,
                "full_name": repo.full_name,
                "updated_at": repo.updated_at.isoformat() if repo.updated_at else None,
                "language": repo.language,
                "description": repo.description
            }
            for repo in recent_repos
        ]
        
        return {
            "username": username,
            "summary": {
                "total_repositories": total_repos,
                "public_repositories": public_repos,
                "private_repositories": private_repos,
                "total_stars": total_stars,
                "total_forks": total_forks,
                "total_watchers": total_watchers,
                "total_size": total_size
            },
            "languages": languages,
            "top_repositories": top_repos_data,
            "recent_activity": recent_activity
        }
        
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar resumo dos reposit√≥rios: {str(e)}")


@router.get("/users/{username}/languages", summary="Obter linguagens do usu√°rio", tags=["Usu√°rios"])
async def get_user_languages(
    username: str,
    client: GitHubClient = Depends(get_github_client)
) -> dict:
    """
    Obt√©m as linguagens de programa√ß√£o mais usadas por um usu√°rio.
    
    Args:
        username: Nome do usu√°rio no GitHub
        
    Returns:
        Dicion√°rio com linguagens e estat√≠sticas
    """
    try:
        languages = await client.get_user_languages(username)
        return {
            "username": username,
            "languages": languages,
            "total_languages": len(languages)
        }
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar linguagens: {str(e)}")


@router.get("/users/{username}/stats", summary="Obter estat√≠sticas do usu√°rio", tags=["Usu√°rios"])
async def get_user_stats(
    username: str,
    client: GitHubClient = Depends(get_github_client)
) -> dict:
    """
    Obt√©m estat√≠sticas detalhadas de um usu√°rio do GitHub.
    
    Args:
        username: Nome do usu√°rio no GitHub
        
    Returns:
        Estat√≠sticas completas do usu√°rio
    """
    try:
        stats = await client.get_user_stats(username)
        return {
            "username": username,
            "user": stats["user"],
            "repositories": stats["repositories"],
            "activity": stats["activity"],
            "languages": stats["languages"],
            "top_repositories": stats["top_repositories"]
        }
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar estat√≠sticas: {str(e)}")


@router.get("/repos/{owner}/{repo}", response_model=GitHubRepository, summary="Obter dados de reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository(
    owner: str,
    repo: str,
    client: GitHubClient = Depends(get_github_client)
) -> GitHubRepository:
    """
    Obt√©m dados de um reposit√≥rio espec√≠fico.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        
    Returns:
        Dados do reposit√≥rio
    """
    try:
        return await client.get_repository(owner, repo)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Reposit√≥rio {owner}/{repo} n√£o encontrado: {str(e)}")


@router.get("/repos/{owner}/{repo}/languages", summary="Obter linguagens do reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository_languages(
    owner: str,
    repo: str,
    client: GitHubClient = Depends(get_github_client)
) -> dict:
    """
    Obt√©m as linguagens de programa√ß√£o de um reposit√≥rio.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        
    Returns:
        Dicion√°rio com linguagens e suas porcentagens
    """
    try:
        languages = await client.get_repository_languages(owner, repo)
        return {
            "repository": f"{owner}/{repo}",
            "languages": languages,
            "total_languages": len(languages)
        }
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar linguagens: {str(e)}")


@router.get("/repos/{owner}/{repo}/events", response_model=List[GitHubEvent], summary="Obter eventos do reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository_events(
    owner: str,
    repo: str,
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubEvent]:
    """
    Obt√©m eventos de um reposit√≥rio.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de eventos do reposit√≥rio
    """
    try:
        return await client.get_repository_events(owner, repo, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar eventos: {str(e)}")


@router.get("/repos/{owner}/{repo}/commits", response_model=List[GitHubCommit], summary="Obter commits do reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository_commits(
    owner: str,
    repo: str,
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubCommit]:
    """
    Obt√©m commits de um reposit√≥rio.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de commits do reposit√≥rio
    """
    try:
        return await client.get_repository_commits(owner, repo, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar commits: {str(e)}")


@router.get("/repos/{owner}/{repo}/issues", response_model=List[GitHubIssue], summary="Obter issues do reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository_issues(
    owner: str,
    repo: str,
    state: str = Query("open", description="Estado das issues (open/closed/all)"),
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubIssue]:
    """
    Obt√©m issues de um reposit√≥rio.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        state: Estado das issues (open/closed/all)
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de issues do reposit√≥rio
    """
    try:
        return await client.get_repository_issues(owner, repo, state, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar issues: {str(e)}")


@router.get("/repos/{owner}/{repo}/pulls", response_model=List[GitHubPullRequest], summary="Obter Pull Requests do reposit√≥rio", tags=["Reposit√≥rios"])
async def get_repository_pull_requests(
    owner: str,
    repo: str,
    state: str = Query("open", description="Estado dos PRs (open/closed/all)"),
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubPullRequest]:
    """
    Obt√©m Pull Requests de um reposit√≥rio.
    
    Args:
        owner: Propriet√°rio do reposit√≥rio
        repo: Nome do reposit√≥rio
        state: Estado dos PRs (open/closed/all)
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de Pull Requests do reposit√≥rio
    """
    try:
        return await client.get_repository_pull_requests(owner, repo, state, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Erro ao buscar Pull Requests: {str(e)}")


@router.get("/search/repositories", response_model=List[GitHubRepository], summary="Buscar reposit√≥rios", tags=["Busca"])
async def search_repositories(
    q: str = Query(..., description="Query de busca"),
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubRepository]:
    """
    Busca reposit√≥rios no GitHub.
    
    Args:
        q: Query de busca
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de reposit√≥rios encontrados
    """
    try:
        return await client.search_repositories(q, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro na busca: {str(e)}")


@router.get("/search/users", response_model=List[GitHubUser], summary="Buscar usu√°rios", tags=["Busca"])
async def search_users(
    q: str = Query(..., description="Query de busca"),
    page: int = Query(1, ge=1, description="N√∫mero da p√°gina"),
    per_page: int = Query(30, ge=1, le=100, description="Itens por p√°gina"),
    client: GitHubClient = Depends(get_github_client)
) -> List[GitHubUser]:
    """
    Busca usu√°rios no GitHub.
    
    Args:
        q: Query de busca
        page: N√∫mero da p√°gina (padr√£o: 1)
        per_page: Itens por p√°gina (padr√£o: 30, m√°ximo: 100)
        
    Returns:
        Lista de usu√°rios encontrados
    """
    try:
        return await client.search_users(q, page, per_page)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro na busca: {str(e)}")


@router.get("/health", summary="Verificar sa√∫de da API", tags=["Sistema"])
async def health_check() -> dict:
    """
    ## üîç Health Check da API
    
    Verifica se a API est√° funcionando corretamente e retorna informa√ß√µes sobre o status do sistema.
    
    ### üìä Informa√ß√µes Retornadas
    
    - **status**: Status da API (healthy/unhealthy)
    - **message**: Mensagem descritiva
    - **version**: Vers√£o da API
    - **timestamp**: Timestamp da verifica√ß√£o
    - **cache**: Estat√≠sticas do cache
    - **environment**: Ambiente (development/production)
    - **uptime**: Tempo de atividade em segundos
    - **memory**: Uso de mem√≥ria
    - **github_api**: Status da API do GitHub
    
    ### üîÑ Uso
    
    ```bash
    curl https://git-api-i3y5.onrender.com/api/v1/health
    ```
    
    ### üìù Exemplo de Resposta
    
    ```json
    {
      "status": "healthy",
      "message": "GitHub Data API est√° funcionando corretamente",
      "version": "0.1.0",
      "timestamp": "2023-12-01T10:00:00",
      "cache": {
        "memory_cache_size": 1,
        "use_redis": false
      },
      "environment": "production",
      "uptime": 3600.5,
      "memory": {
        "rss": "45.2 MB",
        "heap": "12.8 MB"
      },
      "github_api": "connected"
    }
    ```
    
    Returns:
        dict: Status detalhado da API
    """
    from app.services.cache_service import cache_service
    from app.utils.logger import logger

    try:
        import psutil
        import time
        from app.services.github_client import GitHubClient
        
        # Verifica cache
        cache_stats = cache_service.get_stats()
        
        # Calcula uptime
        uptime = time.time() - psutil.boot_time()
        
        # Informa√ß√µes de mem√≥ria
        process = psutil.Process()
        memory_info = process.memory_info()
        memory_stats = {
            "rss": f"{memory_info.rss / 1024 / 1024:.1f} MB",
            "heap": f"{memory_info.vms / 1024 / 1024:.1f} MB"
        }
        
        # Testa conex√£o com GitHub API
        github_status = "connected"
        try:
            client = GitHubClient()
            # Faz uma requisi√ß√£o simples para testar
            await client._make_request("/rate_limit")
        except Exception as e:
            github_status = f"error: {str(e)[:50]}"
            logger.warning(f"GitHub API n√£o acess√≠vel: {e}")
        
        # Log de health check
        logger.info("Health check realizado", extra={
            "type": "health_check",
            "uptime": uptime,
            "memory_rss": memory_info.rss,
            "github_status": github_status
        })
        
        return {
            "status": "healthy",
            "message": "GitHub Data API est√° funcionando corretamente",
            "version": settings.api_version,
            "timestamp": datetime.now().isoformat(),
            "cache": cache_stats,
            "environment": "production" if not settings.debug else "development",
            "uptime": round(uptime, 2),
            "memory": memory_stats,
            "github_api": github_status
        }
    except Exception as e:
        logger.error(f"Health check falhou: {e}", extra={"type": "health_check_error"})
        return {
            "status": "unhealthy",
            "message": f"Erro na API: {str(e)}",
            "version": settings.api_version,
            "timestamp": datetime.now().isoformat()
        }


@router.get("/cache/stats", summary="Estat√≠sticas do cache", tags=["Cache"])
async def cache_stats() -> dict:
    """
    ## üìä Estat√≠sticas do Cache
    
    Retorna informa√ß√µes detalhadas sobre o sistema de cache da API.
    
    ### üìà M√©tricas Dispon√≠veis
    
    - **memory_cache_size**: N√∫mero de itens em cache na mem√≥ria
    - **memory_cache_maxsize**: Tamanho m√°ximo do cache em mem√≥ria
    - **use_redis**: Se o Redis est√° sendo usado
    - **redis_connected**: Status da conex√£o com Redis
    - **redis_used_memory**: Mem√≥ria usada pelo Redis (se dispon√≠vel)
    - **redis_keyspace_hits**: Hits do Redis (se dispon√≠vel)
    - **redis_keyspace_misses**: Misses do Redis (se dispon√≠vel)
    
    ### üîÑ Uso
    
    ```bash
    curl https://git-api-i3y5.onrender.com/api/v1/cache/stats
    ```
    
    ### üìù Exemplo de Resposta
    
    ```json
    {
      "memory_cache_size": 5,
      "memory_cache_maxsize": 1000,
      "use_redis": false,
      "redis_connected": false
    }
    ```
    
    Returns:
        dict: Estat√≠sticas detalhadas do cache
    """
    from app.services.cache_service import cache_service
    return cache_service.get_stats()


@router.delete("/cache/clear", summary="Limpar cache", tags=["Cache"])
async def clear_cache() -> dict:
    """
    ## üóëÔ∏è Limpar Cache
    
    Remove todos os dados armazenados no cache da API.
    
    ### ‚ö†Ô∏è Aten√ß√£o
    
    Esta opera√ß√£o ir√°:
    - Limpar todo o cache em mem√≥ria
    - Limpar todo o cache Redis (se configurado)
    - For√ßar novas requisi√ß√µes √† API do GitHub
    
    ### üîÑ Uso
    
    ```bash
    curl -X DELETE https://git-api-i3y5.onrender.com/api/v1/cache/clear
    ```
    
    ### üìù Exemplo de Resposta
    
    ```json
    {
      "success": true,
      "message": "Cache limpo com sucesso"
    }
    ```
    
    Returns:
        dict: Status da opera√ß√£o de limpeza
    """
    from app.services.cache_service import cache_service
    success = cache_service.clear()
    return {
        "success": success,
        "message": "Cache limpo com sucesso" if success else "Erro ao limpar cache"
    } 